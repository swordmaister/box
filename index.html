<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kekkai Master VR - Hyper Scale</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 20px; box-sizing: border-box; }
        
        .hud-text { color: white; text-shadow: 0 0 5px black; text-align: center; }
        #mode-display { font-size: 2em; font-weight: bold; padding: 10px 30px; border-radius: 10px; transition: background-color 0.5s, color 0.5s; }
        
        .mode-barrier { background-color: rgba(0, 50, 255, 0.5); color: #00FFFF; border: 2px solid #00FFFF; }
        .mode-sandbox { background-color: rgba(255, 100, 0, 0.5); color: #FFD700; border: 2px solid #FFD700; }

        #controls-info { font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="mode-display" class="mode-barrier">ğŸŸ¦ çµç•Œå¸«ãƒ¢ãƒ¼ãƒ‰ (å€ç‡x100)</div>
        <div id="controls-info">
            <div id="info-text">åˆæœŸåŒ–ä¸­...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, camera, renderer, world;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        const dolly = new THREE.Group();
        
        const barriers = [];
        const props = [];
        let playerBody;
        let activeElevator = null;
        let ghostBarrier = null;

        const MODE = { BARRIER: 'BARRIER', SANDBOX: 'SANDBOX' };
        let currentMode = MODE.BARRIER;
        
        // Barrier Formation State
        let formationStartPos = new THREE.Vector3(); // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å§‹ç‚¹
        let barrierOriginPos = new THREE.Vector3();  // çµç•Œã®ç™ºç”ŸåŸç‚¹
        let isRightTriggerDown = false;
        let isRightGripDown = false;
        let gripStartTime = 0;
        
        // Settings
        const SCALING_FACTOR = 80.0; // â˜…å€ç‡è¨­å®š (å‹•ãã®80å€)
        const SPAWN_DISTANCE = 1.5;  // â˜…ç›®ã®å‰ã«å‡ºã™è·é›¢ (ãƒ¡ãƒ¼ãƒˆãƒ«)
        const MOVE_SPEED = 6.0;
        const TURN_SPEED = 2.0;

        let canSwitchMode = true;
        const clapThreshold = 0.15;

        const modeDisplay = document.getElementById('mode-display');
        const infoText = document.getElementById('info-text');

        const timeStep = 1 / 60;
        const maxProps = 100;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101020);
            scene.fog = new THREE.FogExp2(0x101020, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            dolly.position.set(0, 1.6, 0);
            dolly.add(camera);
            scene.add(dolly);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            
            const physicsMat = new CANNON.Material();
            const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { friction: 0.4, restitution: 0.3 });
            world.addContactMaterial(contactMat);

            // Ground
            const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physicsMat });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(groundBody);

            // Player
            playerBody = new CANNON.Body({ mass: 70, shape: new CANNON.Sphere(0.3), material: physicsMat, fixedRotation: true });
            playerBody.position.set(0, 5, 0);
            world.addBody(playerBody);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(50, 50, 0x00ffff, 0x222222);
            scene.add(gridHelper);

            // Controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            dolly.add(controller1); dolly.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            dolly.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            dolly.add(controllerGrip2);

            // Raycaster Line
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-50)]); // é•·ãã—ã¾ã—ãŸ
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
            controller2.add(line);

            // Events
            controller2.addEventListener('selectstart', onRightTriggerStart);
            controller2.addEventListener('selectend', onRightTriggerEnd);
            controller2.addEventListener('squeezestart', onRightGripStart);
            controller2.addEventListener('squeezeend', onRightGripEnd);

            updateUI();
            window.addEventListener('resize', onWindowResize);
        }

        // --- Mode Switching ---
        function switchMode() {
            if (currentMode === MODE.BARRIER) {
                currentMode = MODE.SANDBOX;
                scene.background = new THREE.Color(0x302010);
                scene.fog = new THREE.FogExp2(0x302010, 0.015);
            } else {
                currentMode = MODE.BARRIER;
                scene.background = new THREE.Color(0x101020);
                scene.fog = new THREE.FogExp2(0x101020, 0.02);
            }
            updateUI();
        }

        function updateUI() {
            if (currentMode === MODE.BARRIER) {
                modeDisplay.innerText = "ğŸŸ¦ çµç•Œå¸«ãƒ¢ãƒ¼ãƒ‰ (æ„Ÿåº¦MAX)";
                modeDisplay.className = "mode-barrier";
                infoText.innerHTML = "å³ãƒˆãƒªã‚¬ãƒ¼: éŒ¬æˆ | å³ã‚°ãƒªãƒƒãƒ—: æ»…/è§£<br>åŒæ™‚: ã‚¨ãƒ¬ãƒ™ãƒ¼ã‚¿ãƒ¼ | å·¦:ç§»å‹•(ä¿®æ­£æ¸ˆ) å³:å›è»¢";
            } else {
                modeDisplay.innerText = "ğŸŸ§ ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹";
                modeDisplay.className = "mode-sandbox";
                infoText.innerHTML = "å³A:çƒ å³B:ç­’ å·¦X:ä¸‰è§’ (å‰æ–¹å°„å‡º)<br>å·¦:ç§»å‹• å³:å›è»¢";
            }
        }

        // --- Inputs ---
        function onRightTriggerStart() {
            if (currentMode === MODE.BARRIER) {
                if (isRightGripDown) {
                    startElevator();
                    return;
                }
                // â˜… éŒ¬æˆé–‹å§‹ä½ç½®ã‚’ã€Œã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å ´æ‰€ã€ã§ã¯ãªãã€Œç›®ã®å‰ã€ã«è¨­å®š
                startFormation(); 
            }
            isRightTriggerDown = true;
        }

        function onRightTriggerEnd() {
            if (currentMode === MODE.BARRIER && isRightTriggerDown) {
                finishFormation();
            }
            isRightTriggerDown = false;
        }

        function onRightGripStart() {
            gripStartTime = performance.now();
            isRightGripDown = true;
            if (currentMode === MODE.BARRIER && isRightTriggerDown) {
                startElevator();
                return;
            }
        }

        function onRightGripEnd() {
            const duration = performance.now() - gripStartTime;
            isRightGripDown = false;
            if (duration > 800) {
                currentMode === MODE.BARRIER ? clearAllBarriers() : clearAllProps();
            } else {
                performDestruction();
            }
        }

        function handleControllerInput() {
            const session = renderer.xr.getSession();
            if (!session) return;

            // Mode Switch (Clap)
            const dist = controller1.position.distanceTo(controller2.position);
            if (dist < clapThreshold) {
                if (canSwitchMode) {
                    switchMode();
                    canSwitchMode = false;
                }
            } else if (dist > 0.3) {
                canSwitchMode = true;
            }

            // Input Sources
            for (const source of session.inputSources) {
                if (!source.gamepad) continue;

                // --- Movement & Rotation ---
                if (source.handedness === 'left') {
                    // â˜… å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯: ç§»å‹• (ä¿®æ­£æ¸ˆã¿)
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const x = axes[2]; 
                        const y = axes[3]; // å‰:+1 å¾Œ:-1 (é€šå¸¸) -> åè»¢ãŒå¿…è¦ã‹ã©ã†ã‹ç¢ºèª
                        // ä¸€èˆ¬çš„ãªGamePad API: å‰=-1, å¾Œ=+1
                        // ã“ã“ã§ã¯ç›´æ„Ÿçš„ã«: å‰ã«å€’ã™(y<0) -> å‰é€²
                        
                        if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                            const headRot = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                            const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), headRot.y);
                            const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), headRot.y);
                            
                            // â˜… ä¿®æ­£: å‰é€²ã¯ -y æ–¹å‘ã«ã¯ãŸã‚‰ãã‚ˆã†èª¿æ•´
                            // yãŒ-1(å‰)ã®ã¨ãã€fwdæ–¹å‘ã«é€²ã‚€ -> fwd.multiplyScalar(-y)
                            const move = right.multiplyScalar(x).add(fwd.multiplyScalar(-y)).normalize().multiplyScalar(MOVE_SPEED);
                            
                            playerBody.velocity.x = move.x;
                            playerBody.velocity.z = move.z;
                        } else {
                            playerBody.velocity.x *= 0.9;
                            playerBody.velocity.z *= 0.9;
                        }

                        // å·¦æ‰‹Xãƒœã‚¿ãƒ³ (ä¸‰è§’)
                        if (currentMode === MODE.SANDBOX) {
                             if (source.gamepad.buttons[3]?.pressed && !source.gamepad.buttons[3].wasPressed) {
                                spawnProp('pyramid');
                                source.gamepad.buttons[3].wasPressed = true;
                            } else if (!source.gamepad.buttons[3]?.pressed) {
                                if(source.gamepad.buttons[3]) source.gamepad.buttons[3].wasPressed = false;
                            }
                        }
                    }
                }

                if (source.handedness === 'right') {
                    // â˜… å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯: å›è»¢ (æ–°è¦è¿½åŠ )
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const turn = axes[2]; // Xè»¸
                        if (Math.abs(turn) > 0.2) {
                            dolly.rotation.y -= turn * 0.05 * TURN_SPEED;
                        }
                    }

                    // Aãƒœã‚¿ãƒ³: ã‚¸ãƒ£ãƒ³ãƒ— / çƒ
                    if (source.gamepad.buttons[4]?.pressed && !source.gamepad.buttons[4].wasPressed) {
                        if (currentMode === MODE.SANDBOX) {
                            spawnProp('sphere');
                        } else {
                            // Jump
                            if(playerBody.position.y < 1.0) playerBody.velocity.y = 8;
                        }
                        source.gamepad.buttons[4].wasPressed = true;
                    } else if (!source.gamepad.buttons[4]?.pressed) {
                        if(source.gamepad.buttons[4]) source.gamepad.buttons[4].wasPressed = false;
                    }

                    // Bãƒœã‚¿ãƒ³: ç­’
                    if (currentMode === MODE.SANDBOX) {
                         if (source.gamepad.buttons[5]?.pressed && !source.gamepad.buttons[5].wasPressed) {
                            spawnProp('cylinder');
                            source.gamepad.buttons[5].wasPressed = true;
                        } else if (!source.gamepad.buttons[5]?.pressed) {
                            if(source.gamepad.buttons[5]) source.gamepad.buttons[5].wasPressed = false;
                        }
                    } else {
                        // Barrier Mode Jump (Alternative on A/B)
                         if (source.gamepad.buttons[4]?.pressed && playerBody.position.y < 1.0) {
                            playerBody.velocity.y = 8;
                        }
                    }
                }
            }
        }

        // --- Barrier Logic (Hyper Scale) ---
        function startFormation() {
            // â˜… ç›®ã®å‰ã«ç™ºç”Ÿã•ã›ã‚‹
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller2.quaternion);
            barrierOriginPos.copy(controller2.position).add(direction.multiplyScalar(SPAWN_DISTANCE));
            
            // ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç¾åœ¨ã®ä½ç½®ã‚’åŸºæº–ç‚¹ã¨ã—ã¦ä¿å­˜
            formationStartPos.copy(controller2.position);

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.3, wireframe: true });
            ghostBarrier = new THREE.Mesh(geo, mat);
            ghostBarrier.position.copy(barrierOriginPos);
            ghostBarrier.scale.set(0.1, 0.1, 0.1);
            scene.add(ghostBarrier);
        }

        function updateFormation(controllerPos) {
            if (!ghostBarrier) return;

            // â˜… ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç§»å‹•é‡ (Delta) ã‚’è¨ˆç®—
            const delta = new THREE.Vector3().subVectors(controllerPos, formationStartPos);
            
            // â˜… çˆ†ç™ºçš„ãªã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚° (çµ¶å¯¾å€¤ã§åºƒãŒã‚‹)
            // X, Y, Z ãã‚Œãã‚Œã®å‹•ãã«åˆã‚ã›ã¦æ‹¡å¤§
            const scaleX = Math.max(0.2, Math.abs(delta.x) * SCALING_FACTOR);
            const scaleY = Math.max(0.2, Math.abs(delta.y) * SCALING_FACTOR);
            const scaleZ = Math.max(0.2, Math.abs(delta.z) * SCALING_FACTOR);

            ghostBarrier.scale.set(scaleX, scaleY, scaleZ);

            // â˜… æ‹¡å¤§ã—ã¦ã‚‚ã€ŒåŸç‚¹ã€ã¯ã‚ºãƒ©ã•ãªã„ï¼ˆã‚ã‚‹ã„ã¯ãƒ‰ãƒ©ãƒƒã‚°æ–¹å‘ã«ä¼¸ã°ã™ï¼‰
            // ã“ã“ã§ã¯ã€ŒåŸç‚¹ä¸­å¿ƒã«åºƒãŒã‚‹ã€æŒ™å‹•ã«ã—ã¾ã™ï¼ˆçµç•Œã£ã½ã„ã®ã§ï¼‰
            // ãƒ‰ãƒ©ãƒƒã‚°ã—ãŸæ–¹å‘ã«ä¼¸ã°ã—ãŸã„å ´åˆã¯ position ã‚’ delta * factor / 2 ãšã‚‰ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€
            // è¦–ç·šã®å…ˆã§è†¨å¼µã™ã‚‹æ–¹ãŒæ‰±ã„ã‚„ã™ã„ã§ã™ã€‚
            
            // è£œæ­£: ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚’å³ã«ã‚„ã£ãŸã‚‰å³ã«ä¼¸ã³ã‚‹ã‚ˆã†ã«ä¸­å¿ƒç‚¹ã‚’ç§»å‹•
            const offset = delta.clone().multiplyScalar(SCALING_FACTOR / 2);
            ghostBarrier.position.copy(barrierOriginPos).add(offset);
        }

        function finishFormation() {
            if (!ghostBarrier) return;
            const size = ghostBarrier.scale;
            const pos = ghostBarrier.position.clone();
            
            const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const mat = new THREE.MeshPhongMaterial({ color: 0x0088FF, transparent: true, opacity: 0.7, emissive: 0x001133 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x00FFFF }));
            mesh.add(edges);
            scene.add(mesh);

            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2)) });
            body.position.copy(pos);
            world.addBody(body);

            barriers.push({ mesh, body });
            scene.remove(ghostBarrier);
            ghostBarrier = null;
        }

        // --- Sandbox Logic (Projectile Spawn) ---
        function spawnProp(type) {
            const size = 0.5;
            let geo, shape, mat, body;
            const color = Math.random() * 0xFFFFFF;

            // â˜… ç›®ã®å‰ã‹ã‚‰ç™ºå°„
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller2.quaternion); // å³æ‰‹åŸºæº–
            // å·¦æ‰‹ãƒœã‚¿ãƒ³(ãƒ”ãƒ©ãƒŸãƒƒãƒ‰)ã®å ´åˆã¯å·¦æ‰‹ã‹ã‚‰å‡ºã—ãŸã„ãŒã€æ“ä½œã®çµ±ä¸€æ„Ÿã®ãŸã‚å³æ‰‹æ–¹å‘ã¾ãŸã¯ã‚«ãƒ¡ãƒ©æ–¹å‘æ¨å¥¨ã€‚
            // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«å…¨ã¦ã€Œå³æ‰‹ã®å‘ãã®1.5må…ˆã€ã«å‡ºã—ã¾ã™ã€‚
            const spawnP = controller2.position.clone().add(dir.clone().multiplyScalar(1.5));

            if (type === 'sphere') {
                geo = new THREE.SphereGeometry(size);
                shape = new CANNON.Sphere(size);
            } else if (type === 'cylinder') {
                geo = new THREE.CylinderGeometry(size, size, size*2, 16);
                shape = new CANNON.Cylinder(size, size, size*2, 16);
            } else if (type === 'pyramid') {
                geo = new THREE.ConeGeometry(size, size*2, 4);
                shape = new CANNON.Cylinder(0, size, size*2, 4); 
            }

            mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.5 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnP);
            mesh.castShadow = true;
            scene.add(mesh);

            body = new CANNON.Body({ mass: 20, shape: shape });
            body.position.copy(spawnP);
            // æŠ•ã’å‡ºã™é€Ÿåº¦ã‚’ä¸ãˆã‚‹
            const shootForce = 15; 
            body.velocity.set(dir.x * shootForce, dir.y * shootForce + 2, dir.z * shootForce);
            body.angularVelocity.set(Math.random(), Math.random(), Math.random());
            world.addBody(body);

            props.push({ mesh, body });
            if(props.length > maxProps) {
                const old = props.shift();
                scene.remove(old.mesh);
                world.removeBody(old.body);
            }
        }

        // --- Elevator ---
        function startElevator() {
            if (activeElevator) return;
            const pos = playerBody.position.clone();
            pos.y = 0;
            const w=1.5, d=1.5, h=0.5;
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshBasicMaterial({ color: 0xFFD700, wireframe:true }));
            mesh.position.copy(pos);
            scene.add(mesh);
            const body = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)) });
            body.position.copy(pos);
            world.addBody(body);
            activeElevator = { mesh, body };
        }

        function updateElevator() {
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 6, 0); // Fast elevator
                activeElevator.mesh.position.copy(activeElevator.body.position);
                if (activeElevator.body.position.y > 50) {
                    scene.remove(activeElevator.mesh);
                    world.removeBody(activeElevator.body);
                    activeElevator = null;
                }
            }
        }

        // --- Destruction ---
        function performDestruction() {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller2.matrixWorld);
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const targets = currentMode === MODE.BARRIER ? barriers : props;
            const meshes = targets.map(t => t.mesh);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const index = targets.findIndex(t => t.mesh === hit);
                if (index > -1) {
                    const obj = targets[index];
                    // Explosion Effect
                    const fxGeo = new THREE.SphereGeometry(0.5);
                    const fxMesh = new THREE.Mesh(fxGeo, new THREE.MeshBasicMaterial({color:0xFF0000, transparent:true}));
                    fxMesh.position.copy(obj.mesh.position);
                    scene.add(fxMesh);
                    let scale = 1;
                    const anim = setInterval(()=>{
                        scale *= 1.1; fxMesh.scale.setScalar(scale); fxMesh.material.opacity -= 0.1;
                        if(fxMesh.material.opacity<=0) { clearInterval(anim); scene.remove(fxMesh); }
                    }, 30);

                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                    targets.splice(index, 1);
                }
            }
        }

        function clearAllBarriers() { barriers.forEach(b => { scene.remove(b.mesh); world.removeBody(b.body); }); barriers.length = 0; }
        function clearAllProps() { props.forEach(p => { scene.remove(p.mesh); world.removeBody(p.body); }); props.length = 0; }

        // --- Main Loop ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            world.step(timeStep);
            handleControllerInput();

            if (currentMode === MODE.BARRIER && isRightTriggerDown && ghostBarrier) {
                updateFormation(controller2.position);
            }

            updateElevator();

            props.forEach(p => { p.mesh.position.copy(p.body.position); p.mesh.quaternion.copy(p.body.quaternion); });
            
            // Sync Player View
            dolly.position.copy(playerBody.position);
            dolly.position.y -= 0.3; 

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
