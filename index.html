<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kekkai Master VR v3.1 - Quest 2 (ÊîπËâØ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 10; display: flex; 
            flex-direction: column; justify-content: space-between; 
            align-items: center; padding: 20px; box-sizing: border-box; 
        }
        
        .hud-text { color: white; text-shadow: 0 0 5px black; text-align: center; }
        #mode-display { 
            font-size: 2em; font-weight: bold; padding: 10px 30px; 
            border-radius: 10px; transition: background-color 0.5s, color 0.5s; 
        }
        
        .mode-barrier { background-color: rgba(0, 50, 255, 0.5); color: #00FFFF; border: 2px solid #00FFFF; }
        .mode-sandbox { background-color: rgba(255, 100, 0, 0.5); color: #FFD700; border: 2px solid #FFD700; }

        #controls-info { font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="mode-display" class="mode-barrier">üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ</div>
        <div id="controls-info">
            <div id="info-text">Quest 2 ÂàùÊúüÂåñ‰∏≠...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, camera, renderer, world;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        const dolly = new THREE.Group();
        
        const barriers = []; // { groupMesh, walls: [mesh], wallBodies: [body], trappedObjects: [], isActive: bool, boundingBox }
        const props = []; // { mesh, body, isElevator }
        let playerBody;
        let activeElevator = null;
        let ghostBarrier = null;
        let destructionRay = null;

        const MODE = { BARRIER: 'BARRIER', SANDBOX: 'SANDBOX' };
        let currentMode = MODE.BARRIER;
        
        // Input States
        let formationStartPos = new THREE.Vector3();
        let barrierOriginPos = new THREE.Vector3();
        let barrierWorldRotation = new THREE.Quaternion();
        let isRightTriggerDown = false;
        let isRightGripDown = false;
        let gripStartTime = 0;
        
        // Player jump physics
        let playerVelocityY = 0;
        const GRAVITY = -9.82;
        let canJump = true;
        const GROUND_Y = 1.6; // base eye height

        // Configuration
        const SCALING_FACTOR = 100.0;
        const SPAWN_DISTANCE = 1.5;
        const MOVE_SPEED = 3.5; // Quest 2Áî®„Å´Ë™øÊï¥
        const TURN_SPEED = 1.5;

        let canSwitchMode = true;
        const clapThreshold = 0.25;

        const modeDisplay = document.getElementById('mode-display');
        const infoText = document.getElementById('info-text');
        const timeStep = 1 / 72; // Quest 2„ÅØ72Hz
        const maxProps = 200;

        // Quest 2Áî®„ÅÆÂÖ•Âäõ„Éû„ÉÉ„Éó
        let leftAxes = { x: 0, y: 0 };
        let rightAxes = { x: 0, y: 0 };

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101020);
            scene.fog = new THREE.FogExp2(0x101020, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            dolly.position.set(0, 0, 0);
            dolly.add(camera);
            scene.add(dolly);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, GRAVITY, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            world.defaultContactMaterial.friction = 0.4;
            world.defaultContactMaterial.restitution = 0.3;
            
            const physicsMat = new CANNON.Material('ground');
            const groundBody = new CANNON.Body({ 
                mass: 0, 
                shape: new CANNON.Plane(), 
                material: physicsMat 
            });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(groundBody);

            // „Éó„É¨„Ç§„É§„Éº„ÅØ„Ç≠„Éç„Éû„ÉÜ„Ç£„ÉÉ„ÇØÔºàÁ∏¶ÁßªÂãï„ÅØÊâãÂãï„ÅßÁÆ°ÁêÜÔºâ
            playerBody = new CANNON.Body({ 
                mass: 0,
                type: CANNON.Body.KINEMATIC,
                shape: new CANNON.Sphere(0.3),
                material: physicsMat
            });
            playerBody.position.set(0, GROUND_Y, 0);
            world.addBody(playerBody);

            // Renderer (Quest 2ÊúÄÈÅ©Âåñ)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            renderer.xr.setFramebufferScaleFactor(1.0); // Quest 2Áî®
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(50, 50, 0x00ffff, 0x222222);
            scene.add(gridHelper);

            // Controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            dolly.add(controller1);
            dolly.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            dolly.add(controllerGrip1);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            dolly.add(controllerGrip2);

            // Ray Line
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0,0,0), 
                new THREE.Vector3(0,0,-10)
            ]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5 
            }));
            controller2.add(line);

            // Á†¥Â£äÁî®„É¨„Ç§
            const rayGeo = new THREE.CylinderGeometry(0.01, 0.01, 10, 8);
            const rayMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0 
            });
            destructionRay = new THREE.Mesh(rayGeo, rayMat);
            destructionRay.rotation.x = Math.PI / 2;
            destructionRay.position.z = -5;
            controller2.add(destructionRay);

            // Event Listeners
            controller2.addEventListener('selectstart', onRightTriggerStart);
            controller2.addEventListener('selectend', onRightTriggerEnd);
            controller2.addEventListener('squeezestart', onRightGripStart);
            controller2.addEventListener('squeezeend', onRightGripEnd);

            updateUI();
            window.addEventListener('resize', onWindowResize);
        }

        // --- UI & Mode ---
        function switchMode() {
            if (currentMode === MODE.BARRIER) {
                currentMode = MODE.SANDBOX;
                scene.background = new THREE.Color(0x302010);
                scene.fog = new THREE.FogExp2(0x302010, 0.015);
            } else {
                currentMode = MODE.BARRIER;
                scene.background = new THREE.Color(0x101020);
                scene.fog = new THREE.FogExp2(0x101020, 0.02);
            }
            updateUI();
        }

        function updateUI() {
            if (currentMode === MODE.BARRIER) {
                modeDisplay.innerText = "üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ";
                modeDisplay.className = "mode-barrier";
                infoText.innerHTML = "Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ:ÁßªÂãï | Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ:ÂõûËª¢<br>„Éà„É™„Ç¨„Éº:ÁµêÁïå(Ëß£=Áü≠Êäº„Åó„ÅßÊó¢Â≠òÊ∂àÂéª) | „Ç∞„É™„ÉÉ„Éó:ÊªÖ(ÊΩ∞„Åô)<br>üëè:„É¢„Éº„ÉâÂàáÊõø<br>A:„Ç∏„É£„É≥„Éó";
            } else {
                modeDisplay.innerText = "üüß „Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„Çπ";
                modeDisplay.className = "mode-sandbox";
                infoText.innerHTML = "Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ:ÁßªÂãï | Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ:ÂõûËª¢<br>A:ÁêÉ‰ΩìÁô∫Â∞Ñ | B:„Ç®„É¨„Éô„Éº„Çø„ÉºÁîüÊàê | X:„Éî„É©„Éü„ÉÉ„ÉâÁô∫Â∞Ñ<br>„Ç∞„É™„ÉÉ„Éó:Á†¥Â£ä/ÊªÖ";
            }
        }

        // --- Event Handlers ---
        async function onRightTriggerStart() {
            isRightTriggerDown = true;

            // „Éà„É™„Ç¨„ÉºÁü≠Êäº„ÅóÔºàÈÅ∏ÊäûÔºâ„ÅßÊó¢Â≠òÁµêÁïå„Çí„ÄåËß£„Äç„Åô„ÇãÊåôÂãï„ÇíÂÑ™ÂÖà„Åó„Å¶„ÉÅ„Çß„ÉÉ„ÇØ
            if (currentMode === MODE.BARRIER && !isRightGripDown) {
                const hitIndex = raycastBarrierIndex();
                if (hitIndex !== -1) {
                    performKaiOnBarrier(hitIndex); // Ëß£ÔºöÁµêÁïå„ÇíÊ∂à„ÅôÔºà‰∏≠„ÅÆ„ÇÇ„ÅÆ„ÅØÊΩ∞„Çå„Å™„ÅÑÔºâ
                    return;
                }
            }

            if (currentMode === MODE.BARRIER && !isRightGripDown) {
                startFormation();
            }
        }

        function onRightTriggerEnd() {
            isRightTriggerDown = false;
            
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 0, 0);
                activeElevator = null;
            }
            
            if (currentMode === MODE.BARRIER && ghostBarrier) {
                finishFormation();
            }
        }

        function onRightGripStart() {
            isRightGripDown = true;
            gripStartTime = performance.now();
            
            if (destructionRay) {
                destructionRay.material.opacity = 0.6;
            }
        }

        function onRightGripEnd() {
            isRightGripDown = false;
            
            if (destructionRay) {
                destructionRay.material.opacity = 0;
            }
            
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 0, 0);
                activeElevator = null;
            }

            const duration = performance.now() - gripStartTime;
            
            if (duration > 800) {
                // Èï∑Êäº„ÅóÔºöÂÖ®Ê∂àÂéªÔºàÁèæË°å„ÅÆÊåôÂãïÁ∂≠ÊåÅÔºâ
                currentMode === MODE.BARRIER ? clearAllBarriers() : clearAllProps();
            } else {
                // Áü≠Êäº„ÅóÔºöÊªÖÔºàÂØæË±°ÁµêÁïå„ÇíÊΩ∞„ÅôÔºâ
                performMetsu();
            }
        }

        function handleControllerInput() {
            const session = renderer.xr.getSession();
            if (!session) return;

            // Mode Switch (Clap)
            const worldPos1 = new THREE.Vector3();
            const worldPos2 = new THREE.Vector3();
            controller1.getWorldPosition(worldPos1);
            controller2.getWorldPosition(worldPos2);
            const dist = worldPos1.distanceTo(worldPos2);
            
            if (dist < clapThreshold) {
                if (canSwitchMode) {
                    switchMode();
                    canSwitchMode = false;
                }
            } else if (dist > 0.35) {
                canSwitchMode = true;
            }

            // Gamepad Input (Quest 2)
            for (const source of session.inputSources) {
                if (!source.gamepad) continue;

                // Â∑¶Êâã„Ç≥„É≥„Éà„É≠„Éº„É©„Éº
                if (source.handedness === 'left') {
                    // Â∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ (axes[2], axes[3])
                    if (source.gamepad.axes.length >= 4) {
                        leftAxes.x = source.gamepad.axes[2];
                        leftAxes.y = source.gamepad.axes[3];
                    }
                    
                    // X„Éú„Çø„É≥ (button[4] on Quest 2 left controller)
                    if (currentMode === MODE.SANDBOX) {
                        if (source.gamepad.buttons[4]?.pressed && !source.gamepad.buttons[4].wasPressed) {
                            spawnProp('pyramid');
                            source.gamepad.buttons[4].wasPressed = true;
                        } else if (!source.gamepad.buttons[4]?.pressed && source.gamepad.buttons[4]) {
                            source.gamepad.buttons[4].wasPressed = false;
                        }
                    }
                }

                // Âè≥Êâã„Ç≥„É≥„Éà„É≠„Éº„É©„Éº
                if (source.handedness === 'right') {
                    // Âè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ (axes[2], axes[3])
                    if (source.gamepad.axes.length >= 4) {
                        rightAxes.x = source.gamepad.axes[2];
                        rightAxes.y = source.gamepad.axes[3];
                    }

                    // A„Éú„Çø„É≥ (button[4] on Quest 2 right controller)
                    if (source.gamepad.buttons[4]?.pressed && !source.gamepad.buttons[4].wasPressed) {
                        if (currentMode === MODE.SANDBOX) {
                            spawnProp('sphere');
                        } else {
                            // „Ç∏„É£„É≥„ÉóÊ©üËÉΩÔºàÁµêÁïå„É¢„Éº„ÉâÔºâ
                            if (canJump) {
                                playerVelocityY = 5.0; // ÂàùÈÄü
                                canJump = false;
                            }
                        }
                        source.gamepad.buttons[4].wasPressed = true;
                    } else if (!source.gamepad.buttons[4]?.pressed && source.gamepad.buttons[4]) {
                        source.gamepad.buttons[4].wasPressed = false;
                    }

                    // B„Éú„Çø„É≥ (button[5]) - „Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„Çπ„Åß„ÅØ„Ç®„É¨„Éô„Éº„Çø„ÉºÁîüÊàê
                    if (currentMode === MODE.SANDBOX) {
                        if (source.gamepad.buttons[5]?.pressed && !source.gamepad.buttons[5].wasPressed) {
                            spawnProp('elevator');
                            source.gamepad.buttons[5].wasPressed = true;
                        } else if (!source.gamepad.buttons[5]?.pressed && source.gamepad.buttons[5]) {
                            source.gamepad.buttons[5].wasPressed = false;
                        }
                    } else {
                        // „Éê„É™„Ç¢„É¢„Éº„Éâ„Åß„ÅØB„Å´ÁâπÂà•„Å™ÊåôÂãïÁÑ°„Åó
                    }
                }
            }

            // ÁßªÂãïÂá¶ÁêÜÔºàÂ∑¶„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÔºâ ‚Äî ÂâçÂæåÂ∑¶Âè≥„ÅßÊ≠£Èù¢„ÇíÂêë„ÅÑ„Åü„Åæ„ÅæÂãï„Åè
            if (Math.abs(leftAxes.x) > 0.15 || Math.abs(leftAxes.y) > 0.15) {
                const angle = dolly.rotation.y;
                const forward = new THREE.Vector3(
                    -Math.sin(angle),
                    0,
                    -Math.cos(angle)
                );
                const right = new THREE.Vector3(
                    Math.cos(angle),
                    0,
                    -Math.sin(angle)
                );

                const moveVec = new THREE.Vector3();
                moveVec.addScaledVector(right, leftAxes.x);
                moveVec.addScaledVector(forward, leftAxes.y);
                moveVec.normalize().multiplyScalar(MOVE_SPEED * timeStep);

                playerBody.position.x += moveVec.x;
                playerBody.position.z += moveVec.z;

                // „Ç®„É¨„Éô„Éº„Çø„Éº‰∏ä„Åß‰∏ä‰∏ãÊìç‰ΩúÔºà„Éó„É¨„Ç§„É§„Éº„Åå„Ç®„É¨„Éô„Éº„Çø„Éº‰∏ä„Å´„ÅÑ„ÇãÂ†¥ÂêàÔºâ
                if (activeElevator) {
                    // leftAxes.y„Çí‰Ωø„Å£„Å¶‰∏ä‰∏ã
                    const vy = leftAxes.y * 2.0;
                    activeElevator.body.position.y += vy * timeStep;
                    activeElevator.mesh.position.copy(activeElevator.body.position);
                    // „Ç®„É¨„Éô„Éº„Çø„Éº„Å´‰πó„Å£„Å¶„ÅÑ„Çã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇÇ‰∏ä„Å´ÁßªÂãï„Åï                    // handled in render loop by sync
                }
            }

            // ÂõûËª¢Âá¶ÁêÜÔºàÂè≥„Çπ„ÉÜ„Ç£„ÉÉ„ÇØÔºâ
            if (Math.abs(rightAxes.x) > 0.2) {
                dolly.rotation.y -= rightAxes.x * TURN_SPEED * timeStep;
            }
        }

        // --- Barrier Logic (6Èù¢„ÅÆÂ£Å„ÅßÂõ≤„ÅÜ) ---
        function startFormation() {
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            controller2.getWorldPosition(worldPos);
            controller2.getWorldQuaternion(worldQuat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(worldQuat);
            barrierOriginPos.copy(worldPos).add(dir.multiplyScalar(SPAWN_DISTANCE));
            barrierWorldRotation.copy(worldQuat);
            
            formationStartPos.copy(controller2.position);

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF, 
                transparent: true, 
                opacity: 0.25, 
                wireframe: true 
            });
            ghostBarrier = new THREE.Mesh(geo, mat);
            ghostBarrier.position.copy(barrierOriginPos);
            ghostBarrier.quaternion.copy(barrierWorldRotation);
            ghostBarrier.scale.set(0.1, 0.1, 0.1);
            scene.add(ghostBarrier);
        }

        function updateFormation(controllerPos) {
            if (!ghostBarrier) return;
            
            const delta = new THREE.Vector3().subVectors(controllerPos, formationStartPos);
            
            const scaleX = Math.max(0.2, Math.abs(delta.x) * SCALING_FACTOR);
            const scaleY = Math.max(0.2, Math.abs(delta.y) * SCALING_FACTOR);
            const scaleZ = Math.max(0.2, Math.abs(delta.z) * SCALING_FACTOR);

            // clamp to reasonable
            ghostBarrier.scale.set(
                Math.min(scaleX, 10),
                Math.min(scaleY, 6),
                Math.min(scaleZ, 10)
            );
        }

        function finishFormation() {
            if (!ghostBarrier) return;
            
            const size = new THREE.Vector3(ghostBarrier.scale.x, ghostBarrier.scale.y, ghostBarrier.scale.z);
            const pos = ghostBarrier.position.clone();
            const rot = ghostBarrier.quaternion.clone();

            // Create a group for barrier visuals
            const barrierGroup = new THREE.Group();
            barrierGroup.position.copy(pos);
            barrierGroup.quaternion.copy(rot);

            // Wall visual material
            const wallMat = new THREE.MeshPhongMaterial({
                color: 0x0088FF,
                transparent: true,
                opacity: 0.35,
                side: THREE.DoubleSide
            });

            const wallMeshes = [];
            const wallBodies = [];

            // wall thickness
            const t = 0.12;
            // half sizes
            const hx = size.x / 2;
            const hy = size.y / 2;
            const hz = size.z / 2;

            // helper to create wall at offset
            function createWall(w, h, d, ox, oy, oz) {
                const geo = new THREE.BoxGeometry(w, h, d);
                const mesh = new THREE.Mesh(geo, wallMat.clone());
                mesh.position.set(ox, oy, oz);
                barrierGroup.add(mesh);

                // physics body (static)
                const half = new CANNON.Vec3(w/2, h/2, d/2);
                const box = new CANNON.Box(half);
                const body = new CANNON.Body({ mass: 0 });
                body.addShape(box);
                // compute world position for this wall
                const localPos = new THREE.Vector3(ox, oy, oz).applyQuaternion(rot).add(pos);
                body.position.set(localPos.x, localPos.y, localPos.z);
                // set quaternion
                const q = rot;
                body.quaternion.set(q.x, q.y, q.z, q.w);
                world.addBody(body);

                wallMeshes.push(mesh);
                wallBodies.push(body);
            }

            // Create 6 walls: +X, -X, +Y, -Y, +Z, -Z (slightly inset so interior is hollow)
            createWall(t, size.y, size.z + t*2, hx + t/2, 0, 0); // +X
            createWall(t, size.y, size.z + t*2, -hx - t/2, 0, 0); // -X
            createWall(size.x + t*2, t, size.z + t*2, 0, hy + t/2, 0); // +Y (ceiling)
            createWall(size.x + t*2, t, size.z + t*2, 0, -hy - t/2, 0); // -Y (floor)
            createWall(size.x + t*2, size.y, t, 0, 0, hz + t/2); // +Z
            createWall(size.x + t*2, size.y, t, 0, 0, -hz - t/2); // -Z

            // Compute bounding box for quick containment test (outer bounds)
            const boundingBox = new THREE.Box3().setFromObject(barrierGroup);

            // Detect trapped props inside (by position)
            const trappedObjects = [];
            props.forEach(prop => {
                const p = new THREE.Vector3().copy(prop.body.position);
                if (boundingBox.containsPoint(p)) {
                    trappedObjects.push(prop);
                    // mark visually
                    if (prop.mesh.material && prop.mesh.material.emissive !== undefined) {
                        prop.mesh.material.emissive = new THREE.Color(0xff0000);
                        prop.mesh.material.emissiveIntensity = 0.5;
                    }
                }
            });

            // Add group to scene
            scene.add(barrierGroup);

            barriers.push({
                groupMesh: barrierGroup,
                walls: wallMeshes,
                wallBodies: wallBodies,
                trappedObjects: trappedObjects,
                isActive: true,
                boundingBox: boundingBox
            });

            // remove ghost
            scene.remove(ghostBarrier);
            ghostBarrier = null;
        }

        // --- Ëß£ (Kai) : ÁµêÁïå„ÇíÊ∂à„Åô„Åå‰∏≠„ÅÆ„ÇÇ„ÅÆ„ÅØÊÆã„Åô ---
        function performKaiOnBarrier(index) {
            const b = barriers[index];
            if (!b) return;
            // remove wall bodies and visuals, but keep trapped objects intact
            b.wallBodies.forEach(wb => {
                try { world.removeBody(wb); } catch (e) {}
            });
            b.walls.forEach(wm => {
                if (wm.parent) wm.parent.remove(wm);
            });
            if (b.groupMesh.parent) scene.remove(b.groupMesh);
            // reset trapped visuals
            b.trappedObjects.forEach(p => {
                if (p.mesh && p.mesh.material) {
                    p.mesh.material.emissive = new THREE.Color(0x000000);
                    p.mesh.material.emissiveIntensity = 0;
                }
            });
            barriers.splice(index, 1);
        }

        // --- ÊªÖ (Metsu) : ÁµêÁïå„Å´ÂØæ„Åó„Å¶ÊΩ∞„ÅôÔºà‰∏≠„ÅÆ„ÇÇ„ÅÆ„ÇíÂâäÈô§Ôºâ ---
        function performMetsu() {
            // „É¨„Ç§„ÅßÁµêÁïå„ÇíÁãô„ÅÜ
            const hitIndex = raycastBarrierIndex();
            if (hitIndex === -1) return;

            const barrier = barriers[hitIndex];
            if (!barrier) return;

            // slam effect: ‰∏ãÊñπÂêë„Å´„Ç®„Éï„Çß„ÇØ„ÉàÔºà„Åì„Åì„Åß„ÅØË¶ñË¶ö„ÉªÈü≥„ÅÆ‰ª£„Çè„Çä„Å´Á∞°ÂçòÂá¶ÁêÜÔºâ
            // ÊΩ∞„ÅôÔºö‰∏≠„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÔºàtrappedObjectsÔºâ„ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åô„Çã
            barrier.trappedObjects.forEach(p => {
                try {
                    scene.remove(p.mesh);
                    world.removeBody(p.body);
                } catch (e) {}
                // also remove from props array
                const pi = props.findIndex(x => x === p);
                if (pi !== -1) props.splice(pi, 1);
            });

            // remove walls/bodies/visuals
            barrier.wallBodies.forEach(wb => {
                try { world.removeBody(wb); } catch (e) {}
            });
            if (barrier.groupMesh.parent) scene.remove(barrier.groupMesh);

            // small visual flash on controller ray
            if (destructionRay) {
                destructionRay.material.opacity = 1.0;
                setTimeout(()=>{ if (destructionRay) destructionRay.material.opacity = 0; }, 150);
            }

            barriers.splice(hitIndex, 1);
        }

        // Raycast utility to find barrier under controller2
        function raycastBarrierIndex() {
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            controller2.getWorldPosition(worldPos);
            controller2.getWorldQuaternion(worldQuat);
            
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.copy(worldPos);
            raycaster.ray.direction.set(0, 0, -1).applyQuaternion(worldQuat);
            raycaster.far = 30;

            // check intersects against barrier groupMeshes
            const meshes = barriers.map(b => b.groupMesh);
            const intersects = raycaster.intersectObjects(meshes, true);
            if (intersects.length === 0) return -1;
            // find which barrier contains the intersected object
            const hit = intersects[0].object;
            const parentGroup = meshes.find(m => hit === m || m.children.includes(hit) || m.getObjectById(hit.id));
            const idx = barriers.findIndex(b => b.groupMesh === parentGroup);
            return idx;
        }

        // --- Sandbox: ËêΩ„Å®„Åô / ÁîüÊàê / „Ç®„É¨„Éô„Éº„Çø„Éº ---
        function spawnProp(type) {
            const size = 0.4;
            let geo, shape, body;
            let mass = 20;
            const color = Math.floor(Math.random() * 0xFFFFFF);

            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            camera.getWorldPosition(worldPos);
            camera.getWorldQuaternion(worldQuat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(worldQuat);
            const spawnP = worldPos.clone().add(dir.clone().multiplyScalar(2.0));

            let isElevator = false;

            if (type === 'sphere') {
                geo = new THREE.SphereGeometry(size);
                shape = new CANNON.Sphere(size);
            } else if (type === 'elevator') {
                // elevator: kinematic box/cylinder
                geo = new THREE.BoxGeometry(size*2, 0.2, size*2);
                // use box physics
                shape = new CANNON.Box(new CANNON.Vec3(size, 0.1, size));
                mass = 0; // kinematic (we'll move manually)
                isElevator = true;
            } else if (type === 'cylinder') {
                geo = new THREE.CylinderGeometry(size, size, size * 2, 16);
                shape = new CANNON.Cylinder(size, size, size * 2, 16);
            } else if (type === 'pyramid') {
                geo = new THREE.ConeGeometry(size, size * 2, 4);
                // approximate pyramid as cylinder shape for physics
                shape = new CANNON.Cylinder(0, size, size * 2, 4);
            }

            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnP);
            scene.add(mesh);

            body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            body.position.copy(spawnP);
            if (!isElevator) {
                body.velocity.set(dir.x * 8, dir.y * 6 + 2, dir.z * 8);
                body.angularVelocity.set(
                    (Math.random() - 0.5) * 2, 
                    (Math.random() - 0.5) * 2, 
                    (Math.random() - 0.5) * 2
                );
            } else {
                body.type = CANNON.Body.KINEMATIC;
            }
            world.addBody(body);

            const pObj = { mesh, body, isElevator: isElevator };
            props.push(pObj);
            
            if (props.length > maxProps) {
                const old = props.shift();
                scene.remove(old.mesh);
                try { world.removeBody(old.body); } catch (e) {}
            }
        }

        function clearAllBarriers() {
            barriers.forEach(b => {
                try { b.wallBodies.forEach(wb => world.removeBody(wb)); } catch (e) {}
                if (b.groupMesh.parent) scene.remove(b.groupMesh);
            });
            barriers.length = 0;
        }

        function clearAllProps() {
            props.forEach(p => {
                scene.remove(p.mesh);
                try { world.removeBody(p.body); } catch (e) {}
            });
            props.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // physics step for dynamic bodies (kinematic positions set manually)
            world.step(timeStep);

            handleControllerInput();

            // Update formation while holding trigger
            if (currentMode === MODE.BARRIER && isRightTriggerDown && ghostBarrier && !isRightGripDown) {
                updateFormation(controller2.position);
            }

            // Sync props meshes with physics bodies
            props.forEach(p => {
                if (!p.body || !p.mesh) return;
                // For kinematic elevator, body position may be moved directly
                p.mesh.position.copy(p.body.position);
                p.mesh.quaternion.copy(p.body.quaternion);
            });

            // Update player vertical physics (jump + gravity)
            playerVelocityY += GRAVITY * timeStep;
            playerBody.position.y += playerVelocityY * timeStep;

            if (playerBody.position.y <= GROUND_Y) {
                playerBody.position.y = GROUND_Y;
                playerVelocityY = 0;
                canJump = true;
            }

            // Dolly follows player (camera height accounted for)
            dolly.position.copy(playerBody.position);

            // Detect if player stands on an elevator to activate it
            activeElevator = null;
            for (const p of props) {
                if (!p.isElevator) continue;
                // compute bounding box of elevator mesh
                const bb = new THREE.Box3().setFromObject(p.mesh);
                const playerPos = new THREE.Vector3().copy(playerBody.position);
                // check if player's feet (y slightly below playerBody) are within elevator AABB
                if (playerPos.x > bb.min.x && playerPos.x < bb.max.x &&
                    playerPos.z > bb.min.z && playerPos.z < bb.max.z &&
                    Math.abs(playerPos.y - p.mesh.position.y) < 0.6) {
                    activeElevator = p;
                    break;
                }
            }

            // If an elevator is active and left stick up/down applied, move it (handled in handleControllerInput)
            // Also ensure any objects standing on elevator go up/down with it
            if (activeElevator) {
                // Propagate elevator movement to any props that are resting near its top
                const topY = activeElevator.mesh.position.y + 0.15;
                // find props that are on elevator surface (within small epsilon)
                props.forEach(other => {
                    if (other === activeElevator) return;
                    const dx = other.body.position.x - activeElevator.body.position.x;
                    const dz = other.body.position.z - activeElevator.body.position.z;
                    const withinX = Math.abs(dx) < 1.2;
                    const withinZ = Math.abs(dz) < 1.2;
                    const onTop = Math.abs(other.body.position.y - topY) < 0.3;
                    if (withinX && withinZ && onTop) {
                        // match y to elevator
                        other.body.position.y = topY + 0.05;
                        other.mesh.position.copy(other.body.position);
                    }
                });
                // if player stands on it, keep the player's y synced to elevator top when elevator moves
                if (activeElevator) {
                    const top = activeElevator.body.position.y + 0.15;
                    // if player close enough horizontally and on top
                    const pp = playerBody.position;
                    const ex = activeElevator.body.position.x, ez = activeElevator.body.position.z;
                    if (Math.abs(pp.x - ex) < 1.2 && Math.abs(pp.z - ez) < 1.2 && Math.abs(pp.y - top) < 0.8) {
                        playerBody.position.y = top + 0.9; // eye height
                    }
                }
            }

            // If a barrier exists, update its bounding boxes (static so usually not necessary)
            barriers.forEach(b => {
                // keep boundingBox current (in case elevator/props moved)
                b.boundingBox = new THREE.Box3().setFromObject(b.groupMesh);
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
