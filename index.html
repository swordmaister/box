<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kekkai Master VR v2.2</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 10; display: flex; 
            flex-direction: column; justify-content: space-between; 
            align-items: center; padding: 20px; box-sizing: border-box; 
        }
        
        .hud-text { color: white; text-shadow: 0 0 5px black; text-align: center; }
        #mode-display { 
            font-size: 2em; font-weight: bold; padding: 10px 30px; 
            border-radius: 10px; transition: background-color 0.5s, color 0.5s; 
        }
        
        .mode-barrier { background-color: rgba(0, 50, 255, 0.5); color: #00FFFF; border: 2px solid #00FFFF; }
        .mode-sandbox { background-color: rgba(255, 100, 0, 0.5); color: #FFD700; border: 2px solid #FFD700; }

        #controls-info { font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="mode-display" class="mode-barrier">üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ</div>
        <div id="controls-info">
            <div id="info-text">ÂàùÊúüÂåñ‰∏≠...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, camera, renderer, world;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        const dolly = new THREE.Group();
        
        const barriers = [];
        const props = [];
        let playerBody;
        let activeElevator = null;
        let ghostBarrier = null;
        let destructionRay = null;

        const MODE = { BARRIER: 'BARRIER', SANDBOX: 'SANDBOX' };
        let currentMode = MODE.BARRIER;
        
        // Input States
        let formationStartPos = new THREE.Vector3();
        let barrierOriginPos = new THREE.Vector3();
        let barrierWorldRotation = new THREE.Quaternion();
        let isRightTriggerDown = false;
        let isRightGripDown = false;
        let gripStartTime = 0;
        
        // Configuration
        const SCALING_FACTOR = 100.0;
        const SPAWN_DISTANCE = 1.5;
        const MOVE_SPEED = 0.08; // ‚òÖ„Éï„É¨„Éº„É†Âçò‰Ωç„ÅÆÁßªÂãïÈÄüÂ∫¶„Å´Â§âÊõ¥
        const TURN_SPEED = 2.0;

        let canSwitchMode = true;
        const clapThreshold = 0.25; // ‚òÖÂà§ÂÆöË∑ùÈõ¢„ÇíÂ∞ë„ÅóÂ∫É„Åí„Åü

        const modeDisplay = document.getElementById('mode-display');
        const infoText = document.getElementById('info-text');
        const timeStep = 1 / 60;
        const maxProps = 100;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101020);
            scene.fog = new THREE.FogExp2(0x101020, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            dolly.position.set(0, 1.6, 0);
            dolly.add(camera);
            scene.add(dolly);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            
            const physicsMat = new CANNON.Material();
            const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { 
                friction: 0.4, 
                restitution: 0.3 
            });
            world.addContactMaterial(contactMat);

            const groundBody = new CANNON.Body({ 
                mass: 0, 
                shape: new CANNON.Plane(), 
                material: physicsMat 
            });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(groundBody);

            playerBody = new CANNON.Body({ 
                mass: 70, 
                shape: new CANNON.Sphere(0.3), 
                material: physicsMat, 
                fixedRotation: true,
                linearDamping: 0.9 // ‚òÖÊ∏õË°∞„ÇíËøΩÂä†
            });
            playerBody.position.set(0, 5, 0);
            world.addBody(playerBody);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(50, 50, 0x00ffff, 0x222222);
            scene.add(gridHelper);

            // Controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            dolly.add(controller1);
            dolly.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            dolly.add(controllerGrip1);
            
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            dolly.add(controllerGrip2);

            // Ray Line
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0,0,0), 
                new THREE.Vector3(0,0,-10)
            ]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5 
            }));
            controller2.add(line);

            // Á†¥Â£äÁî®„É¨„Ç§
            const rayGeo = new THREE.CylinderGeometry(0.01, 0.01, 10, 8);
            const rayMat = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0 
            });
            destructionRay = new THREE.Mesh(rayGeo, rayMat);
            destructionRay.rotation.x = Math.PI / 2;
            destructionRay.position.z = -5;
            controller2.add(destructionRay);

            // Event Listeners
            controller2.addEventListener('selectstart', onRightTriggerStart);
            controller2.addEventListener('selectend', onRightTriggerEnd);
            controller2.addEventListener('squeezestart', onRightGripStart);
            controller2.addEventListener('squeezeend', onRightGripEnd);

            updateUI();
            window.addEventListener('resize', onWindowResize);
        }

        // --- UI & Mode ---
        function switchMode() {
            if (currentMode === MODE.BARRIER) {
                currentMode = MODE.SANDBOX;
                scene.background = new THREE.Color(0x302010);
                scene.fog = new THREE.FogExp2(0x302010, 0.015);
            } else {
                currentMode = MODE.BARRIER;
                scene.background = new THREE.Color(0x101020);
                scene.fog = new THREE.FogExp2(0x101020, 0.02);
            }
            updateUI();
        }

        function updateUI() {
            if (currentMode === MODE.BARRIER) {
                modeDisplay.innerText = "üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ (ÊÑüÂ∫¶x100)";
                modeDisplay.className = "mode-barrier";
                infoText.innerHTML = "„Éà„É™„Ç¨„Éº:Èå¨Êàê | „Éà„É™„Ç¨„Éº+„Ç∞„É™„ÉÉ„Éó:„Ç®„É¨„Éô„Éº„Çø„Éº(Èï∑Êäº„Åó)<br>„Ç∞„É™„ÉÉ„Éó:ÊªÖ/Ëß£ | üëè:„É¢„Éº„ÉâÂàáÊõø";
            } else {
                modeDisplay.innerText = "üüß „Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„Çπ";
                modeDisplay.className = "mode-sandbox";
                infoText.innerHTML = "Âè≥A/B/Â∑¶X:Âõ≥ÂΩ¢Áô∫Â∞Ñ | „Ç∞„É™„ÉÉ„Éó:Á†¥Â£ä<br>üëè:„É¢„Éº„ÉâÂàáÊõø";
            }
        }

        // --- Event Handlers ---
        function onRightTriggerStart() {
            isRightTriggerDown = true;
            if (currentMode === MODE.BARRIER && !isRightGripDown) {
                startFormation();
            }
        }

        function onRightTriggerEnd() {
            isRightTriggerDown = false;
            
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 0, 0);
                activeElevator = null;
            }
            
            if (currentMode === MODE.BARRIER && ghostBarrier) {
                finishFormation();
            }
        }

        function onRightGripStart() {
            isRightGripDown = true;
            gripStartTime = performance.now();
            
            if (destructionRay) {
                destructionRay.material.opacity = 0.6;
            }
        }

        function onRightGripEnd() {
            isRightGripDown = false;
            
            if (destructionRay) {
                destructionRay.material.opacity = 0;
            }
            
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 0, 0);
                activeElevator = null;
            }

            const duration = performance.now() - gripStartTime;
            
            if (duration > 800) {
                currentMode === MODE.BARRIER ? clearAllBarriers() : clearAllProps();
            } else {
                if (!activeElevator) performDestruction();
            }
        }

        function handleControllerInput() {
            const session = renderer.xr.getSession();
            if (!session) return;

            // ‚òÖMode Switch (Clap) - „ÉØ„Éº„É´„ÉâÂ∫ßÊ®ô„ÅßÂà§ÂÆö
            const worldPos1 = new THREE.Vector3();
            const worldPos2 = new THREE.Vector3();
            controller1.getWorldPosition(worldPos1);
            controller2.getWorldPosition(worldPos2);
            const dist = worldPos1.distanceTo(worldPos2);
            
            if (dist < clapThreshold) {
                if (canSwitchMode) {
                    switchMode();
                    canSwitchMode = false;
                }
            } else if (dist > 0.35) {
                canSwitchMode = true;
            }

            // Elevator Logic
            if (currentMode === MODE.BARRIER) {
                if (isRightTriggerDown && isRightGripDown) {
                    if (ghostBarrier) {
                        scene.remove(ghostBarrier);
                        ghostBarrier = null;
                    }
                    
                    if (!activeElevator) {
                        startElevator();
                    }
                    
                    if (activeElevator) {
                        activeElevator.body.velocity.set(0, 4.0, 0);
                    }
                } else if (activeElevator && !(isRightTriggerDown && isRightGripDown)) {
                    activeElevator.body.velocity.set(0, 0, 0);
                }
            }

            // ‚òÖGamepad polling - ÁßªÂãïÂá¶ÁêÜ„ÇíÊîπÂñÑ
            for (const source of session.inputSources) {
                if (!source.gamepad) continue;

                // Â∑¶Êâã: ÁßªÂãï
                if (source.handedness === 'left') {
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const x = axes[2]; // Â∑¶Âè≥
                        const y = axes[3]; // ÂâçÂæå
                        
                        if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                            // dolly„ÅÆÂêë„Åç„ÇíÂü∫Ê∫ñ„Å´ÁßªÂãï„Éô„ÇØ„Éà„É´Ë®àÁÆó
                            const angle = dolly.rotation.y;
                            const fwd = new THREE.Vector3(
                                Math.sin(angle), 
                                0, 
                                Math.cos(angle)
                            );
                            const right = new THREE.Vector3(
                                Math.cos(angle), 
                                0, 
                                -Math.sin(angle)
                            );
                            
                            // ‚òÖÁßªÂãïÊñπÂêë„ÇíË®àÁÆó (y„ÅØÂâçÊñπ„ÅåË≤†„Å™„ÅÆ„ÅßÂèçËª¢)
                            const moveDir = new THREE.Vector3();
                            moveDir.addScaledVector(right, x);
                            moveDir.addScaledVector(fwd, -y);
                            moveDir.normalize();
                            
                            // ‚òÖÁâ©ÁêÜ„Éú„Éá„Ç£„Å´Áõ¥Êé•Âäõ„ÇíÂä†„Åà„Çã
                            const force = moveDir.multiplyScalar(MOVE_SPEED);
                            playerBody.velocity.x = force.x;
                            playerBody.velocity.z = force.z;
                        } else {
                            // „Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÇíÈõ¢„Åó„Åü„ÇâÊ∏õÈÄü
                            playerBody.velocity.x *= 0.8;
                            playerBody.velocity.z *= 0.8;
                        }
                    }
                    
                    // Â∑¶ÊâãX„Éú„Çø„É≥ („Éî„É©„Éü„ÉÉ„ÉâÁô∫Â∞Ñ)
                    if (currentMode === MODE.SANDBOX) {
                        if (source.gamepad.buttons[3]?.pressed && !source.gamepad.buttons[3].wasPressed) {
                            spawnProp('pyramid');
                            source.gamepad.buttons[3].wasPressed = true;
                        } else if (!source.gamepad.buttons[3]?.pressed && source.gamepad.buttons[3]) {
                            source.gamepad.buttons[3].wasPressed = false;
                        }
                    }
                }

                // Âè≥Êâã: ÂõûËª¢ & „Ç¢„ÇØ„Ç∑„Éß„É≥
                if (source.handedness === 'right') {
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const turn = axes[2];
                        if (Math.abs(turn) > 0.2) {
                            dolly.rotation.y -= turn * 0.05 * TURN_SPEED;
                        }
                    }

                    // A„Éú„Çø„É≥: ÁêÉ / „Ç∏„É£„É≥„Éó
                    if (source.gamepad.buttons[4]?.pressed && !source.gamepad.buttons[4].wasPressed) {
                        if (currentMode === MODE.SANDBOX) {
                            spawnProp('sphere');
                        } else if (playerBody.position.y < 2.0) {
                            playerBody.velocity.y = 8;
                        }
                        source.gamepad.buttons[4].wasPressed = true;
                    } else if (!source.gamepad.buttons[4]?.pressed && source.gamepad.buttons[4]) {
                        source.gamepad.buttons[4].wasPressed = false;
                    }

                    // B„Éú„Çø„É≥: ÂÜÜÊü±
                    if (currentMode === MODE.SANDBOX) {
                        if (source.gamepad.buttons[5]?.pressed && !source.gamepad.buttons[5].wasPressed) {
                            spawnProp('cylinder');
                            source.gamepad.buttons[5].wasPressed = true;
                        } else if (!source.gamepad.buttons[5]?.pressed && source.gamepad.buttons[5]) {
                            source.gamepad.buttons[5].wasPressed = false;
                        }
                    }
                }
            }
        }

        // --- Barrier Logic ---
        function startFormation() {
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            controller2.getWorldPosition(worldPos);
            controller2.getWorldQuaternion(worldQuat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(worldQuat);
            barrierOriginPos.copy(worldPos).add(dir.multiplyScalar(SPAWN_DISTANCE));
            barrierWorldRotation.copy(worldQuat);
            
            formationStartPos.copy(controller2.position);

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF, 
                transparent: true, 
                opacity: 0.3, 
                wireframe: true 
            });
            ghostBarrier = new THREE.Mesh(geo, mat);
            ghostBarrier.position.copy(barrierOriginPos);
            ghostBarrier.quaternion.copy(barrierWorldRotation);
            ghostBarrier.scale.set(0.1, 0.1, 0.1);
            scene.add(ghostBarrier);
        }

        function updateFormation(controllerPos) {
            if (!ghostBarrier) return;
            
            const delta = new THREE.Vector3().subVectors(controllerPos, formationStartPos);
            
            const scaleX = Math.max(0.2, Math.abs(delta.x) * SCALING_FACTOR);
            const scaleY = Math.max(0.2, Math.abs(delta.y) * SCALING_FACTOR);
            const scaleZ = Math.max(0.2, Math.abs(delta.z) * SCALING_FACTOR);

            ghostBarrier.scale.set(scaleX, scaleY, scaleZ);
        }

        function finishFormation() {
            if (!ghostBarrier) return;
            
            const size = ghostBarrier.scale.clone();
            const pos = ghostBarrier.position.clone();
            const rot = ghostBarrier.quaternion.clone();
            
            const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const mat = new THREE.MeshPhongMaterial({ 
                color: 0x0088FF, 
                transparent: true, 
                opacity: 0.7, 
                emissive: 0x001133 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.quaternion.copy(rot);
            
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geo), 
                new THREE.LineBasicMaterial({ color: 0x00FFFF })
            );
            mesh.add(edges);
            scene.add(mesh);

            const body = new CANNON.Body({ 
                mass: 0, 
                shape: new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2)) 
            });
            body.position.copy(pos);
            body.quaternion.copy(rot);
            world.addBody(body);

            barriers.push({ mesh, body });
            scene.remove(ghostBarrier);
            ghostBarrier = null;
        }

        // --- Elevator ---
        function startElevator() {
            const pos = playerBody.position.clone();
            pos.y = 0.2;
            const w = 1.5, d = 1.5, h = 0.2;
            
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(w, h, d), 
                new THREE.MeshBasicMaterial({ 
                    color: 0xFFD700, 
                    opacity: 0.8, 
                    transparent: true 
                })
            );
            mesh.position.copy(pos);
            scene.add(mesh);
            
            const body = new CANNON.Body({ 
                mass: 0, 
                type: CANNON.Body.KINEMATIC, 
                shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)) 
            });
            body.position.copy(pos);
            world.addBody(body);
            
            activeElevator = { mesh, body };
        }

        // --- Sandbox Props ---
        function spawnProp(type) {
            const size = 0.4;
            let geo, shape, mat, body;
            const color = Math.random() * 0xFFFFFF;

            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            camera.getWorldPosition(worldPos);
            camera.getWorldQuaternion(worldQuat);
            
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(worldQuat);
            const spawnP = worldPos.clone().add(dir.clone().multiplyScalar(2.0));

            if (type === 'sphere') {
                geo = new THREE.SphereGeometry(size);
                shape = new CANNON.Sphere(size);
            } else if (type === 'cylinder') {
                geo = new THREE.CylinderGeometry(size, size, size * 2, 16);
                shape = new CANNON.Cylinder(size, size, size * 2, 16);
            } else if (type === 'pyramid') {
                geo = new THREE.ConeGeometry(size, size * 2, 4);
                shape = new CANNON.Cylinder(0, size, size * 2, 4);
            }

            mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnP);
            mesh.castShadow = true;
            scene.add(mesh);

            body = new CANNON.Body({ mass: 20, shape: shape });
            body.position.copy(spawnP);
            body.velocity.set(dir.x * 10, dir.y * 10 + 2, dir.z * 10);
            body.angularVelocity.set(
                (Math.random() - 0.5) * 2, 
                (Math.random() - 0.5) * 2, 
                (Math.random() - 0.5) * 2
            );
            world.addBody(body);

            props.push({ mesh, body });
            
            if (props.length > maxProps) {
                const old = props.shift();
                scene.remove(old.mesh);
                world.removeBody(old.body);
            }
        }

        function performDestruction() {
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            controller2.getWorldPosition(worldPos);
            controller2.getWorldQuaternion(worldQuat);
            
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.copy(worldPos);
            raycaster.ray.direction.set(0, 0, -1).applyQuaternion(worldQuat);
            raycaster.far = 20;

            const targets = currentMode === MODE.BARRIER ? barriers : props;
            const meshes = targets.map(t => t.mesh);
            const intersects = raycaster.intersectObjects(meshes, true);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const parent = hit.parent?.type === 'Mesh' ? hit.parent : hit;
                const index = targets.findIndex(t => t.mesh === parent || t.mesh === hit);
                
                if (index > -1) {
                    const obj = targets[index];
                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                    targets.splice(index, 1);
                    
                    if (destructionRay) {
                        destructionRay.material.opacity = 1.0;
                        setTimeout(() => {
                            if (destructionRay) destructionRay.material.opacity = isRightGripDown ? 0.6 : 0;
                        }, 100);
                    }
                }
            }
        }

        function clearAllBarriers() {
            barriers.forEach(b => {
                scene.remove(b.mesh);
                world.removeBody(b.body);
            });
            barriers.length = 0;
        }

        function clearAllProps() {
            props.forEach(p => {
                scene.remove(p.mesh);
                world.removeBody(p.body);
            });
            props.length = 0;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            world.step(timeStep);
            handleControllerInput();

            if (currentMode === MODE.BARRIER && isRightTriggerDown && ghostBarrier && !isRightGripDown) {
                updateFormation(controller2.position);
            }

            if (activeElevator) {
                activeElevator.mesh.position.copy(activeElevator.body.position);
                activeElevator.mesh.quaternion.copy(activeElevator.body.quaternion);
            }

            props.forEach(p => {
                p.mesh.position.copy(p.body.position);
                p.mesh.quaternion.copy(p.body.quaternion);
            });
            
            dolly.position.copy(playerBody.position);
            dolly.position.y -= 0.3;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
