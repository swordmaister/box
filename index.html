<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kekkai Master VR v2.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 20px; box-sizing: border-box; }
        
        .hud-text { color: white; text-shadow: 0 0 5px black; text-align: center; }
        #mode-display { font-size: 2em; font-weight: bold; padding: 10px 30px; border-radius: 10px; transition: background-color 0.5s, color 0.5s; }
        
        .mode-barrier { background-color: rgba(0, 50, 255, 0.5); color: #00FFFF; border: 2px solid #00FFFF; }
        .mode-sandbox { background-color: rgba(255, 100, 0, 0.5); color: #FFD700; border: 2px solid #FFD700; }

        #controls-info { font-size: 1.2em; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="mode-display" class="mode-barrier">üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ</div>
        <div id="controls-info">
            <div id="info-text">ÂàùÊúüÂåñ‰∏≠...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, camera, renderer, world;
        let controller1, controller2;
        let controllerGrip1, controllerGrip2;
        const dolly = new THREE.Group();
        
        const barriers = [];
        const props = [];
        let playerBody;
        let activeElevator = null; // ÁèæÂú®Êìç‰Ωú‰∏≠„ÅÆ„Ç®„É¨„Éô„Éº„Çø„Éº
        let ghostBarrier = null;

        const MODE = { BARRIER: 'BARRIER', SANDBOX: 'SANDBOX' };
        let currentMode = MODE.BARRIER;
        
        // Input States
        let formationStartPos = new THREE.Vector3(); // „Éâ„É©„ÉÉ„Ç∞ÈñãÂßãÊôÇ„ÅÆ„Ç≥„É≥„Éà„É≠„Éº„É©„Éº‰ΩçÁΩÆ
        let barrierOriginPos = new THREE.Vector3();  // ÁµêÁïå„ÅÆ‰∏≠ÂøÉÁÇπÔºàÁõÆ„ÅÆÂâçÔºâ
        let isRightTriggerDown = false;
        let isRightGripDown = false;
        let gripStartTime = 0;
        
        // Configuration
        const SCALING_FACTOR = 100.0; // ‚òÖË∂ÖÊã°Â§ßÂÄçÁéá
        const SPAWN_DISTANCE = 1.5;   // ‚òÖÁõÆ„ÅÆÂâç„Å´Âá∫„ÅôË∑ùÈõ¢
        const MOVE_SPEED = 6.0;
        const TURN_SPEED = 2.0;

        let canSwitchMode = true;
        const clapThreshold = 0.15;

        const modeDisplay = document.getElementById('mode-display');
        const infoText = document.getElementById('info-text');
        const timeStep = 1 / 60;
        const maxProps = 100;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101020);
            scene.fog = new THREE.FogExp2(0x101020, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            dolly.position.set(0, 1.6, 0);
            dolly.add(camera);
            scene.add(dolly);

            // Physics
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.SAPBroadphase(world);
            
            const physicsMat = new CANNON.Material();
            const contactMat = new CANNON.ContactMaterial(physicsMat, physicsMat, { friction: 0.4, restitution: 0.3 });
            world.addContactMaterial(contactMat);

            const groundBody = new CANNON.Body({ mass: 0, shape: new CANNON.Plane(), material: physicsMat });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(groundBody);

            playerBody = new CANNON.Body({ mass: 70, shape: new CANNON.Sphere(0.3), material: physicsMat, fixedRotation: true });
            playerBody.position.set(0, 5, 0);
            world.addBody(playerBody);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            renderer.xr.setReferenceSpaceType('local-floor');
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const gridHelper = new THREE.GridHelper(50, 50, 0x00ffff, 0x222222);
            scene.add(gridHelper);

            // Controllers
            controller1 = renderer.xr.getController(0);
            controller2 = renderer.xr.getController(1);
            dolly.add(controller1); dolly.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();
            const g1 = renderer.xr.getControllerGrip(0); g1.add(controllerModelFactory.createControllerModel(g1)); dolly.add(g1);
            const g2 = renderer.xr.getControllerGrip(1); g2.add(controllerModelFactory.createControllerModel(g2)); dolly.add(g2);

            // Ray Line
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-50)]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
            controller2.add(line);

            // Event Listeners (Discrete Actions)
            controller2.addEventListener('selectstart', onRightTriggerStart);
            controller2.addEventListener('selectend', onRightTriggerEnd);
            controller2.addEventListener('squeezestart', onRightGripStart);
            controller2.addEventListener('squeezeend', onRightGripEnd);

            updateUI();
            window.addEventListener('resize', onWindowResize);
        }

        // --- UI & Mode ---
        function switchMode() {
            if (currentMode === MODE.BARRIER) {
                currentMode = MODE.SANDBOX;
                scene.background = new THREE.Color(0x302010);
                scene.fog = new THREE.FogExp2(0x302010, 0.015);
            } else {
                currentMode = MODE.BARRIER;
                scene.background = new THREE.Color(0x101020);
                scene.fog = new THREE.FogExp2(0x101020, 0.02);
            }
            updateUI();
        }

        function updateUI() {
            if (currentMode === MODE.BARRIER) {
                modeDisplay.innerText = "üü¶ ÁµêÁïåÂ∏´„É¢„Éº„Éâ (ÊÑüÂ∫¶x100)";
                modeDisplay.className = "mode-barrier";
                infoText.innerHTML = "„Éà„É™„Ç¨„Éº:Èå¨Êàê | „Éà„É™„Ç¨„Éº+„Ç∞„É™„ÉÉ„Éó:„Ç®„É¨„Éô„Éº„Çø„Éº(Èï∑Êäº„Åó)<br>„Ç∞„É™„ÉÉ„Éó:ÊªÖ/Ëß£ | üëè:„É¢„Éº„ÉâÂàáÊõø";
            } else {
                modeDisplay.innerText = "üüß „Çµ„É≥„Éâ„Éú„ÉÉ„ÇØ„Çπ";
                modeDisplay.className = "mode-sandbox";
                infoText.innerHTML = "Âè≥A/B/Â∑¶X:Âõ≥ÂΩ¢Áô∫Â∞Ñ | „Ç∞„É™„ÉÉ„Éó:Á†¥Â£ä<br>üëè:„É¢„Éº„ÉâÂàáÊõø";
            }
        }

        // --- Event Handlers ---
        function onRightTriggerStart() {
            isRightTriggerDown = true;
            if (currentMode === MODE.BARRIER) {
                // „Ç®„É¨„Éô„Éº„Çø„ÉºÂà§ÂÆö„ÅØ„É´„Éº„ÉóÂÜÖ„ÅßÂá¶ÁêÜ„Åô„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÁµêÁïåÁîüÊàê„ÅÆ„Åø
                if (!isRightGripDown) {
                    startFormation();
                }
            }
        }

        function onRightTriggerEnd() {
            isRightTriggerDown = false;
            // „Ç®„É¨„Éô„Éº„Çø„ÉºÂÅúÊ≠¢Ôºà„Ç¢„ÇØ„ÉÜ„Ç£„ÉñËß£Èô§Ôºâ
            if (activeElevator) {
                activeElevator = null; // Âõ∫ÂÆöÂåñÔºà„Ç≠„Éç„Éû„ÉÜ„Ç£„ÉÉ„ÇØ„ÅÆ„Åæ„ÅæÊîæÁΩÆÔºâ
            }
            // ÁµêÁïåÂõ∫ÂÆö
            if (currentMode === MODE.BARRIER && ghostBarrier) {
                finishFormation();
            }
        }

        function onRightGripStart() {
            isRightGripDown = true;
            gripStartTime = performance.now();
        }

        function onRightGripEnd() {
            isRightGripDown = false;
            // „Ç®„É¨„Éô„Éº„Çø„ÉºÂÅúÊ≠¢
            if (activeElevator) {
                activeElevator = null;
            }

            const duration = performance.now() - gripStartTime;
            // Èï∑Êäº„Åó„ÅßÂÖ®Ê∂àÂéª
            if (duration > 800) {
                currentMode === MODE.BARRIER ? clearAllBarriers() : clearAllProps();
            } else {
                // „Ç®„É¨„Éô„Éº„Çø„Éº„Å´‰Ωø„Å£„Å¶„ÅÑ„Å™„Åë„Çå„Å∞Á†¥Â£ä„ÇíÂÆüË°å
                if (!activeElevator) performDestruction();
            }
        }

        function handleControllerInput() {
            const session = renderer.xr.getSession();
            if (!session) return;

            // Mode Switch (Clap)
            const dist = controller1.position.distanceTo(controller2.position);
            if (dist < clapThreshold) {
                if (canSwitchMode) {
                    switchMode();
                    canSwitchMode = false;
                }
            } else if (dist > 0.3) canSwitchMode = true;

            // Elevator Logic (Hold Trigger + Grip)
            if (currentMode === MODE.BARRIER) {
                if (isRightTriggerDown && isRightGripDown) {
                    // „Ç≠„É£„É≥„Çª„É´Âá¶ÁêÜ: ÁµêÁïåÁîüÊàê‰∏≠„Å™„Çâ‰∏≠Ê≠¢
                    if (ghostBarrier) { scene.remove(ghostBarrier); ghostBarrier = null; }
                    
                    if (!activeElevator) {
                        startElevator(); // Êñ∞Ë¶è‰ΩúÊàê
                    } else {
                        // Êó¢„Å´„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™„Çâ‰∏äÊòáÂá¶ÁêÜ„ÇíÂëº„Å≥Âá∫„ÅóÔºà„É´„Éº„ÉóÂÜÖ„ÅßÂÆüË°åÔºâ
                        liftElevator();
                    }
                }
            }

            // Gamepad polling
            for (const source of session.inputSources) {
                if (!source.gamepad) continue;

                // --- Â∑¶Êâã: ÁßªÂãï (‰øÆÊ≠£Áâà) ---
                if (source.handedness === 'left') {
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const x = axes[2]; // Â∑¶Âè≥
                        const y = axes[3]; // ÂâçÂæå (ÈÄöÂ∏∏ ‰∏ä=-1, ‰∏ã=1)
                        
                        if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                            // „Ç´„É°„É©„ÅÆÂêë„ÅçÂü∫Ê∫ñ
                            const headRot = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                            const fwd = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), headRot.y);
                            const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), headRot.y);
                            
                            // ‚òÖ‰øÆÊ≠£: y„ÅØÂâç(-1)„Å™„ÅÆ„Åß„ÄÅÂâçÈÄ≤„Åô„Çã„Å´„ÅØ fwd.multiplyScalar(-y)
                            const move = right.multiplyScalar(x).add(fwd.multiplyScalar(-y)).normalize().multiplyScalar(MOVE_SPEED);
                            
                            playerBody.velocity.x = move.x;
                            playerBody.velocity.z = move.z;
                        } else {
                            playerBody.velocity.x *= 0.9;
                            playerBody.velocity.z *= 0.9;
                        }
                    }
                    
                    // Â∑¶ÊâãX„Éú„Çø„É≥ („Éî„É©„Éü„ÉÉ„ÉâÁô∫Â∞Ñ)
                    if (currentMode === MODE.SANDBOX) {
                         if (source.gamepad.buttons[3]?.pressed && !source.gamepad.buttons[3].wasPressed) {
                            spawnProp('pyramid');
                            source.gamepad.buttons[3].wasPressed = true;
                        } else if (!source.gamepad.buttons[3]?.pressed) {
                            if(source.gamepad.buttons[3]) source.gamepad.buttons[3].wasPressed = false;
                        }
                    }
                }

                // --- Âè≥Êâã: ÂõûËª¢ & „Ç¢„ÇØ„Ç∑„Éß„É≥ ---
                if (source.handedness === 'right') {
                    const axes = source.gamepad.axes;
                    if (axes.length >= 4) {
                        const turn = axes[2]; // Â∑¶Âè≥
                        if (Math.abs(turn) > 0.2) {
                            dolly.rotation.y -= turn * 0.05 * TURN_SPEED;
                        }
                    }

                    // A„Éú„Çø„É≥: ÁêÉ / „Ç∏„É£„É≥„Éó
                    if (source.gamepad.buttons[4]?.pressed && !source.gamepad.buttons[4].wasPressed) {
                        if (currentMode === MODE.SANDBOX) spawnProp('sphere');
                        else if(playerBody.position.y < 2.0) playerBody.velocity.y = 8;
                        source.gamepad.buttons[4].wasPressed = true;
                    } else if (!source.gamepad.buttons[4]?.pressed && source.gamepad.buttons[4]) {
                        source.gamepad.buttons[4].wasPressed = false;
                    }

                    // B„Éú„Çø„É≥: ÂÜÜÊü±
                    if (currentMode === MODE.SANDBOX) {
                         if (source.gamepad.buttons[5]?.pressed && !source.gamepad.buttons[5].wasPressed) {
                            spawnProp('cylinder');
                            source.gamepad.buttons[5].wasPressed = true;
                        } else if (!source.gamepad.buttons[5]?.pressed && source.gamepad.buttons[5]) {
                            source.gamepad.buttons[5].wasPressed = false;
                        }
                    }
                }
            }
        }

        // --- Barrier Logic ---
        function startFormation() {
            // ‚òÖ ÁõÆ„ÅÆÂâç„Å´Âá∫„ÅôË®àÁÆó
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controller2.quaternion);
            barrierOriginPos.copy(controller2.position).add(dir.multiplyScalar(SPAWN_DISTANCE));
            
            formationStartPos.copy(controller2.position); // „Éâ„É©„ÉÉ„Ç∞Ë®àÁÆóÁî®

            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, transparent: true, opacity: 0.3, wireframe: true });
            ghostBarrier = new THREE.Mesh(geo, mat);
            ghostBarrier.position.copy(barrierOriginPos);
            ghostBarrier.scale.set(0.1, 0.1, 0.1);
            scene.add(ghostBarrier);
        }

        function updateFormation(controllerPos) {
            if (!ghostBarrier) return;
            const delta = new THREE.Vector3().subVectors(controllerPos, formationStartPos);
            
            // ‚òÖ ÊÑüÂ∫¶100ÂÄç„Çπ„Ç±„Éº„É™„É≥„Ç∞
            const scaleX = Math.max(0.2, Math.abs(delta.x) * SCALING_FACTOR);
            const scaleY = Math.max(0.2, Math.abs(delta.y) * SCALING_FACTOR);
            const scaleZ = Math.max(0.2, Math.abs(delta.z) * SCALING_FACTOR);

            ghostBarrier.scale.set(scaleX, scaleY, scaleZ);
            
            // ‰∏≠ÂøÉ‰ΩçÁΩÆË™øÊï¥ÔºàÂ∫É„Åå„Å£„ÅüÂàÜ„Å†„ÅëÂéüÁÇπ„Åã„Çâ„Åö„Çâ„Åô„Å™„Çâ„Åì„Çå„Å†„Åå„ÄÅ‰ªäÂõû„ÅØÂéüÁÇπ‰∏≠ÂøÉÊã°Â§ßÔºâ
            // ghostBarrier.position.copy(barrierOriginPos);
        }

        function finishFormation() {
            if (!ghostBarrier) return;
            const size = ghostBarrier.scale;
            const pos = ghostBarrier.position.clone();
            
            const geo = new THREE.BoxGeometry(size.x, size.y, size.z);
            const mat = new THREE.MeshPhongMaterial({ color: 0x0088FF, transparent: true, opacity: 0.7, emissive: 0x001133 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color: 0x00FFFF }));
            mesh.add(edges);
            scene.add(mesh);

            const body = new CANNON.Body({ mass: 0, shape: new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2)) });
            body.position.copy(pos);
            world.addBody(body);

            barriers.push({ mesh, body });
            scene.remove(ghostBarrier);
            ghostBarrier = null;
        }

        // --- Elevator (Hold to Rise) ---
        function startElevator() {
            // Ë∂≥ÂÖÉ„Å´ÁîüÊàê
            const pos = playerBody.position.clone();
            pos.y = 0.2; // Âú∞Èù¢„Çà„ÇäÂ∞ë„Åó‰∏ä
            const w=1.5, d=1.5, h=0.2;
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshBasicMaterial({ color: 0xFFD700, opacity:0.8, transparent:true }));
            mesh.position.copy(pos);
            scene.add(mesh);
            
            const body = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, shape: new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)) });
            body.position.copy(pos);
            world.addBody(body);
            
            activeElevator = { mesh, body };
        }

        function liftElevator() {
            if (activeElevator) {
                // ‰∏äÊòáÈÄüÂ∫¶
                activeElevator.body.velocity.set(0, 4.0, 0);
            }
        }

        function stopElevator() {
            // ÈÄüÂ∫¶„Çº„É≠„Å´„Åó„Å¶Âõ∫ÂÆö
            if (activeElevator) {
                activeElevator.body.velocity.set(0, 0, 0);
            }
        }

        // --- Sandbox Props ---
        function spawnProp(type) {
            const size = 0.4;
            let geo, shape, mat, body;
            const color = Math.random() * 0xFFFFFF;

            // ‚òÖ ÁõÆ„ÅÆÂâç 2m „Å´Áô∫Â∞Ñ
            const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); 
            const spawnP = dolly.position.clone().add(dir.clone().multiplyScalar(2.0));

            if (type === 'sphere') { geo = new THREE.SphereGeometry(size); shape = new CANNON.Sphere(size); } 
            else if (type === 'cylinder') { geo = new THREE.CylinderGeometry(size, size, size*2, 16); shape = new CANNON.Cylinder(size, size, size*2, 16); } 
            else if (type === 'pyramid') { geo = new THREE.ConeGeometry(size, size*2, 4); shape = new CANNON.Cylinder(0, size, size*2, 4); }

            mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(spawnP);
            mesh.castShadow = true;
            scene.add(mesh);

            body = new CANNON.Body({ mass: 20, shape: shape });
            body.position.copy(spawnP);
            body.velocity.set(dir.x * 10, dir.y * 10 + 2, dir.z * 10);
            body.angularVelocity.set(Math.random(), Math.random(), Math.random());
            world.addBody(body);

            props.push({ mesh, body });
            if(props.length > maxProps) {
                const old = props.shift();
                scene.remove(old.mesh);
                world.removeBody(old.body);
            }
        }

        function performDestruction() {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller2.matrixWorld);
            const raycaster = new THREE.Raycaster();
            raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const targets = currentMode === MODE.BARRIER ? barriers : props;
            const meshes = targets.map(t => t.mesh);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const hit = intersects[0].object;
                const index = targets.findIndex(t => t.mesh === hit);
                if (index > -1) {
                    const obj = targets[index];
                    scene.remove(obj.mesh);
                    world.removeBody(obj.body);
                    targets.splice(index, 1);
                }
            }
        }

        function clearAllBarriers() { barriers.forEach(b => { scene.remove(b.mesh); world.removeBody(b.body); }); barriers.length = 0; }
        function clearAllProps() { props.forEach(p => { scene.remove(p.mesh); world.removeBody(p.body); }); props.length = 0; }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            world.step(timeStep);
            handleControllerInput();

            if (currentMode === MODE.BARRIER && isRightTriggerDown && ghostBarrier && !isRightGripDown) {
                updateFormation(controller2.position);
            }

            // „Ç®„É¨„Éô„Éº„Çø„Éº‰ΩçÁΩÆÊõ¥Êñ∞
            if (activeElevator) {
                activeElevator.mesh.position.copy(activeElevator.body.position);
                // Êäº„Åó„Å¶„Å™„ÅÑ„Å®„Åç„ÅØÊ≠¢„ÇÅ„ÇãÂá¶ÁêÜ (handleControllerInput„ÅßliftElevatorÂëº„Å∞„Çå„Å™„ÅÑ„ÅÆ„ÅßÊÖ£ÊÄß„ÅßÂãï„Åè„ÅÆ„ÇíÈò≤„Åê)
                if (!(isRightTriggerDown && isRightGripDown)) {
                    activeElevator.body.velocity.set(0,0,0);
                }
            }

            props.forEach(p => { p.mesh.position.copy(p.body.position); p.mesh.quaternion.copy(p.body.quaternion); });
            
            dolly.position.copy(playerBody.position);
            dolly.position.y -= 0.3; 

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
